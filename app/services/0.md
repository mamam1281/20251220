0. 먼저 전체 방향부터 딱 정리

당장 목표를 이렇게 잡자:

앱 첫 화면 = 로그인 페이지

로그인 성공하면 → 대시보드/홈에서 한 번에 이걸 다 보이게

내 정보(테스트 계정이면 그 표시)

시즌패스 상태

오늘 가능한 게임들 목록

각 게임별 코인 잔액 (룰렛/복권/주사위)

today-feature, TEST_MODE, 1일 1페이지 이런 건 일단 전부 꺼버리고

코인만 있으면 언제든 룰렛/복권/주사위 진입 가능

코인 없으면 버튼 비활성 + “관리자에게 문의”

실제 데이터 흐름 확인

로그인 → DB(user/로그) 업데이트

각 게임 페이지에서 play → DB 로그

관리자 쪽에서 그 로그 보고 다른 플랫폼(텔레그램)으로 수동 보상지급

이걸 기준으로 각 문제(1~6)를 풀어볼게.

1) 로그인 페이지가 첫 화면이 아닌 문제
✅ 해야 할 것

라우팅을 바꿔서 / 진입 시 무조건 LoginPage가 뜨게 만들기.

토큰이 없으면 어떤 URL을 쳐도 /login으로 리다이렉트.

토큰이 있으면 → /home 같은 메인 화면으로 보내기.

IDE AI에게 이렇게 말하면 됨
1) Frontend 라우팅/로그인 플로우 정리

- UserRoutes.tsx에서 현재 루트("/") 진입 시 렌더되는 컴포넌트를 LoginPage로 바꿔줘.
- LoginPage.tsx 컴포넌트를 새로 만들어줘. 내용은:
  - "테스트 계정으로 로그인" 버튼 하나만 있는 심플 화면.
  - 클릭 시 /api/auth/token 에 POST:
    { "user_id": 999, "external_id": "test-qa-999" }
  - 응답에서 access_token을 받아서 localStorage 또는 auth store에 저장.
  - 이후 /home(또는 /dashboard)로 navigate.

- ProtectedRoute(또는 비슷한 컴포넌트)가 있다면:
  - 토큰이 없으면 항상 /login으로 리다이렉트하게 수정.
  - /roulette, /dice, /lottery, /ranking, /season-pass, /home 모두 ProtectedRoute로 감싸줘.

2) 유저 플로우 정립 (로그인 → 보상까지)

당신이 말한 플로우를 정리하면 이렇게야:

로그인

관리자가 계정을 허가/인증

(우리 시스템 기준으로는: 그냥 user.status=ACTIVE + 코인 지급이면 “허가된 계정” 취급)

화면 진입

시즌패스 상태 확인

오늘 게임(들) 확인

게임 진입 (코인 있으면 O / 없으면 X)

게임 결과 / 시즌패스 / 로그 기록

유저가 텔레그램으로 ‘보상 요청’

관리자가 다른 플랫폼에서 수동 보상 지급

이걸 시스템에 맞게 한 줄로 요약하면:

로그인 → 토큰 발급 → 홈에서 “내 시즌패스 + 보유 코인 + 게임 리스트” 한 번에 보여주기 → 게임 선택 → 플레이 → DB에 로그/시즌패스 반영 → 관리자가 로그 보고 다른 시스템에서 보상.

IDE AI에게 유저 플로우를 이렇게 설명해
2) User Flow를 기준으로 홈/대시보드 화면을 구성해줘.

- /home (또는 /dashboard) 컴포넌트를 만들거나 수정해서, 로그인 후 첫 화면에 다음 정보를 한 번에 보여줘:
  1) 현재 로그인한 유저 정보 (user_id, external_id 표시)
  2) Season-pass status API 결과 (level, xp, 오늘 도장 여부)
  3) 각 게임별 진입 카드:
     - Roulette: 현재 잔여 코인 수, "바로 입장" 버튼
     - Dice: 현재 잔여 코인 수, "바로 입장" 버튼
     - Lottery: 현재 잔여 코인 수, "바로 입장" 버튼
  4) “최근 보상/플레이 이력” 섹션은 나중에 추가할 수 있도록 placeholder만 둬도 좋음.

- 이 화면에서 유저는:
  - 각 게임 카드를 클릭해서 /roulette, /dice, /lottery 등으로 이동.
  - 코인이 없으면 해당 게임 카드에 "코인 없음 - 관리자에게 문의" 표시.

3) TEST_MODE 다 귀찮고, 그냥 바로 되게 만들기
지금까지 구조

today-feature + TEST_MODE + FeatureGate 조합으로
“오늘만 열리는 페이지” / “테스트일 때 무시” 같은 게 묶여 있었음.

지금 원하는 구조

일단 전부 항상 열려 있어야 함.

나중에 “크리스마스 1주일 이벤트” 모드로 다시 쓸 수는 있지만,
지금은 개발/검증 단계라서 “조건부 게이트”를 과감하게 꺼버리는 게 맞음.

IDE AI에게 이렇게 지시
3) today-feature와 TEST_MODE를 당분간 완전히 비활성화해줘.

- FeatureGate.tsx 파일을 열어서,
  - 어떤 플래그든 상관 없이 children을 항상 렌더하도록 단순화해줘.
  - 단, today-feature API 호출이 있다면:
    - 실패해도 화면을 막지 말고, 상단에 "오늘 이벤트 정보 로드 실패" 정도의 작은 경고만 띄우게 변경.
- featureFlags.ts의 isTestModeEnabled, isFeatureGateEnabled 값은 나중에 다시 쓸 수 있도록 남겨두되,
  - 현재는 FeatureGate에서 이 값들로 라우팅을 막지 않게 해줘.

결과적으로:
- /roulette, /dice, /lottery, /ranking, /season-pass 는
  - 로그인만 되어 있으면 항상 접근 가능해야 한다.

4) “코인 기반 게임이면 하루 하나씩 열 필요 없다” → 구조 변경 방향

완전히 동의.
이제는:

게임 오픈/클로즈 = 일정이 아니라 “코인 지급 여부”가 기준이 되는 거지.

그래서:

feature_schedule / today-feature는 “이벤트성”으로만 남겨두고,
진짜 진입 제어는 코인 레이어가 담당하게 만들면 돼.

백엔드 쪽 방향만 잡아두자 (IDE 프롬프트용)
4) 게임 진입 조건을 "오늘 스케줄"에서 "코인 잔액"으로 옮기는 준비를 해줘.

- RouletteService, DiceService, LotteryService의 play 메서드에서:
  - today-feature 타입 검사(오늘이 맞는 날인지 확인)는 일단 주석 처리하거나 TODO로 남겨두고,
  - 나중에 이벤트 모드에서만 다시 사용할 수 있도록 해줘.

- 대신, 각 게임의 /status 및 /play 로직에
  - token_balance(예: ROULETTE_COIN, DICE_TOKEN, LOTTERY_TICKET) 개념을 추가할 수 있도록
  - status 응답 schema와 프론트 타입 정의에 token_balance, token_type 필드를 추가할 준비를 해줘.
  - 실제 코인 차감 로직은 다음 단계에서 구현할 예정이니, 현재는 코드 주석과 인터페이스만 잡아줘.


(코인 월렛/차감 로직은 별도 단계로 잡고, 지금은 오늘 1개만 열리는 구조에서 탈출이 우선.)

5) FE–BE–DB 전역 동기화 확인

지금 꼭 체크해야 할 포인트는 3가지야:

로그인 → DB(user + user_event_log) 업데이트 되는지

각 게임 페이지에서 play → 해당 로그 테이블(roulette_log / dice_log / lottery_log)에 쌓이는지

프론트에서 보여주는 값 = DB에 실제 저장된 값과 일치하는지

IDE AI에게 “체크용 스크립트/설명”을 이렇게 만들어달라고 해
5) FE-BE-DB 동기화가 눈으로 확인 가능하도록, README/LOCAL_TESTING_GUIDE에 다음 시나리오를 추가해줘.

시나리오 A: 로그인 동기화 확인
- Step 1: 프론트에서 테스트 계정으로 로그인.
- Step 2: 백엔드 DB에서 user 테이블 조회 → 해당 user_id의 last_login_at, last_login_ip가 업데이트 되었는지 확인하는 SQL 예시 추가.
- Step 3: user_event_log에서 feature_type='AUTH', event_name='AUTH_LOGIN' 로그가 생성되었는지 확인하는 SQL 예시 추가.

시나리오 B: 게임 플레이 동기화 확인
- Step 1: /roulette 페이지에서 1회 플레이.
- Step 2: DB의 roulette_log에서 해당 user_id로 가장 최근 row를 조회하는 SQL 예시 제공.
- Step 3: 화면에 보였던 결과와 DB 로그의 reward_type, reward_amount가 일치하는지 비교하도록 가이드 작성.

시나리오 C: 시즌패스 연동 확인
- Step 1: 시즌패스 도장을 찍는 행동(또는 임시 API)을 트리거.
- Step 2: season_pass_progress, season_pass_stamp_log, season_pass_reward_log에서 해당 user_id row를 조회하는 SQL 예시 추가.
- Step 3: 프론트의 시즌패스 화면과 DB 값이 일치하는지 확인하는 절차 정리.

6) 관리자 어드민 페이지 확인

지금 단계에서 최소한 필요한 관리자 기능:

유저 검색 (user_id / external_id로)

해당 유저의 게임 이력/시즌패스 상태 조회

(추가 예정) 유저에게 코인 지급 / 회수

우선은 “관리자 UI가 실제로 존재하는지”부터 IDE AI에게 확인시키자.

6) 관리자 어드민 페이지/라우팅 존재 여부를 확인해줘.

- frontend에서 Admin 관련 라우터/페이지가 있는지 전체 검색:
  - "Admin", "관리자", "/admin" 같은 문자열 기준으로 검색.
  - 있으면:
    - 어떤 URL에서 접근하는지,
    - 현재 무엇을 보여주는지(예: 유저 리스트, 랭킹 업로드 등),
    - 여기서 향후 "코인 지급" 기능을 붙일 수 있는지 정리해줘.
  - 없으면:
    - /admin/login, /admin/dashboard 같은 기본 뼈대 라우트와 페이지를 만들어서,
    - 최소한 "user_id 입력 → 해당 유저 최근 로그/시즌패스 상태를 보여주는 화면" 정도는 scaffold 형태로 생성해줘.

7. 한 문장으로 다시 정리하면

지금은 “크리스마스 1주일 / today-feature / TEST_MODE” 다 집어넣느라 꼬여 있으니까,
일단 로그인 → 홈 → 여러 게임 + 시즌패스가 항상 보이고,
각 행동이 DB에 잘 쌓이는 “기본 구조”부터 완전히 고정시키고,
그 위에 코인/이벤트/일자별 제한을 다시 얹자.