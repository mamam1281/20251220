CH25 기능 확장 및 세그멘테이션/개인화 설계를 위한 기술 명세

이 문서는 CH25 프로젝트의 기존 프론트엔드·어드민 코드 구조를 분석하여, 새로 제안된 기능(사용자 데이터 수집, 세그멘테이션, 맞춤 캠페인, 쿠폰 코드, 랜덤 보상, 후기 게시판, 소셜 공유)을 구현하기 위한 구체적인 기술 설계를 제시한다.

1. 현재 구조 분석
1.1 프론트엔드 및 어드민 구조

일반 사용자 UI는 React + Vite로 작성되어 있으며, RoulettePage, DicePage, LotteryPage, RankingPage, SeasonPassPage 등 게임 페이지를 제공한다. 각 페이지는 src/hooks/useRoulette.ts 같은 커스텀 훅을 통해 백엔드 API와 통신한다. HTTP 클라이언트는 axios를 기반으로 한 userApi로 구성되어 있으며, 기본 URL은 .env의 VITE_API_BASE_URL를 참조한다
github.com
.

어드민 UI는 별도의 라우터(src/router/AdminRoutes.tsx)에서 관리된다. 대시보드와 SeasonListPage, RouletteConfigPage, DiceConfigPage, LotteryConfigPage, GameTokenGrantPage, GameTokenLogsPage, UserAdminPage 등의 페이지가 있으며, 백엔드 API는 adminApi (src/admin/api/httpClient.ts)를 통해 /admin/api 네임스페이스의 엔드포인트와 통신한다
github.com
.

데이터 관리는 프론트엔드에서 react-query를 통해 수행한다. 예를 들어 UserAdminPage는 createUser, fetchUsers 등의 API를 호출하여 사용자 CRUD를 제공한다
github.com
.

토큰/플레이 로그 관리는 GameTokenLogsPage에서 fetchWallets, fetchRecentPlayLogs, fetchLedger, revokeGameTokens 등을 호출하여 조회·회수를 수행한다
github.com
.

백엔드 스키마는 리포지토리 내에 포함되어 있다. ORM 모델은 app/models/*, 마이그레이션은 alembic/versions/* 에서 확인 가능하다.

참고로 AdminUser 응답의 season_level은 user 테이블 컬럼이 아니라, 레벨 진행도(SeasonPassProgress.current_level)를 active 시즌 기준으로 합성(enrich)해서 내려주는 값이다. 동일하게 xp도 admin 사용자 목록/상세에서는 active 시즌의 SeasonPassProgress.current_xp를 합성해 내려줄 수 있다.

1.2 기존 데이터 모델(백엔드 기준으로 교정)

현재 리포지토리 기준 실제 테이블/구조는 아래와 같다.

user (테이블명: user)
- id, external_id(unique), nickname, password_hash, level, xp, status, last_login_at, last_login_ip, created_at, updated_at
- season_level 컬럼은 없음(관리자 API에서 season_pass_progress를 보고 합성해서 내려줌)

game_wallets (테이블명: user_game_wallet)
- id, user_id(FK user.id), token_type(ROULETTE_COIN/DICE_TOKEN/LOTTERY_TICKET/CC_COIN), balance, updated_at
- 제약: (user_id, token_type) 유니크(uq_user_token_type)

ledger (테이블명: user_game_wallet_ledger)
- id, user_id(FK user.id), token_type, delta, balance_after, reason, label, meta_json(JSON), created_at

play_logs (단일 테이블이 아니라 “조회용 통합 뷰”에 가까움)
- /admin/api/game-tokens/play-logs 는 roulette_log / dice_log / lottery_log 를 UNION ALL 해서 최신순으로 조회한다.
- roulette_log: id, user_id, config_id, segment_id, reward_type, reward_amount, created_at (+ roulette_segment.label join)
- dice_log: id, user_id, config_id, user_dice_1, user_dice_2, user_sum, dealer_dice_1, dealer_dice_2, dealer_sum, result, reward_type, reward_amount, created_at
- lottery_log: id, user_id, config_id, prize_id, reward_type, reward_amount, created_at (+ lottery_prize.label join)

2. 데이터 수집 및 세그멘테이션 확장
\
※ 이 문서의 2번 섹션은 **현재 코드베이스에 실제로 구현된 범위**(user_activity/user_segment 수집·배치·어드민 관리, event_id 기반 idempotency, segment_rule DB 규칙관리)에 맞춰 작성한다.
2.1 사용자 행동 데이터 테이블 신설

신규 기능을 위해 다음과 같은 테이블을 추가한다. 백엔드 스택이 FastAPI + SQLAlchemy + Alembic(MySQL)이므로, app/models/*에 ORM 모델을 추가하고 alembic/versions/* 마이그레이션으로 생성/변경한다.

user_activity
필드명	타입	설명
id	bigint PK	활동 고유 키
user_id	int FK→user.id	사용자 ID
last_login_at	datetime	마지막 로그인 시각(선택: 이미 user.last_login_at이 있어 중복 저장을 피하려면 이 컬럼은 생략 가능)
last_charge_at	datetime	마지막 충전(입금) 시각
roulette_plays	int	룰렛 플레이 누적 횟수
dice_plays	int	주사위 플레이 누적 횟수
lottery_plays	int	복권 스크래치 플레이 누적 횟수
total_play_duration	int	총 플레이 시간(초)
last_bonus_used_at	datetime	마지막 보너스 사용 시각
created_at	datetime	레코드 생성 시각
updated_at	datetime	레코드 업데이트 시각
수집 방식

게임 페이지에서 플레이 시 서버에 이벤트를 전송한다. 현재 구현은 로그인 유저를 기준으로 /api/activity/record에 event_type(ROULETTE_PLAY/DICE_PLAY/LOTTERY_PLAY 등)과 부가 값(value/meta_json)을 전송하면, 서버가 user_activity를 증가/갱신한다.

현재 구현된 요청/응답 스키마(백엔드 기준)
- 요청: ActivityRecordRequest
	- event_type: "ROULETTE_PLAY" | "DICE_PLAY" | "LOTTERY_PLAY" | "BONUS_USED" | "PLAY_DURATION"
	- event_id: UUID | null (옵션)
	- value: int | null (옵션, 예: PLAY_DURATION의 초 단위)
	- meta_json: object | null (옵션)
- 응답: ActivityRecordResponse
	- user_id: int
	- updated_at: datetime

idempotency(중복 방지) 정책(현재 구현)
- 문제: 프론트가 네트워크 재시도/중복 클릭/페이지 전환 등으로 같은 이벤트를 중복 전송하면 카운트가 과증가할 수 있음
- 해결: event_id(UUID)를 이벤트마다 1회 생성해 전송하고, 서버는 event_id를 기준으로 **한 번만 처리**한다.
	- 신규 테이블: user_activity_event
		- event_id(문자열 36) UNIQUE (전역 유니크)
		- user_id, event_type, created_at
	- 서버 동작: 동일 event_id가 이미 존재하면 카운터/시각 갱신 없이 no-op(그대로 반환)
	- 주의: UNIQUE가 event_id 단독이므로 event_id는 **전역적으로 유니크**해야 하며, UUID v4 같은 랜덤 UUID를 사용하면 충분하다.

로그인은 이미 user.last_login_at / user.last_login_ip로 추적하므로, user_activity.last_login_at을 별도로 두지 않아도 된다(필요 시 user 테이블 값을 미러링하거나 조회 시 조인으로 해결).

충전/입금(last_charge_at) 데이터 소스(현재 코드베이스 기준)

- 이 프로젝트의 “입금액”은 결제 트랜잭션 테이블이 있는 구조가 아니라, 관리자가 외부 플랫폼의 누적 입금액을 입력(upsert)하는 외부랭킹 데이터로 들어온다.
- 저장 테이블: external_ranking_data
	- deposit_amount: 유저별 누적 입금액(관리자 입력값)
	- updated_at: 관리자 입력이 반영된 시각(서버 기준)
- 입력 경로: /admin/api/external-ranking (서비스: app/services/admin_external_ranking_service.py)

따라서 user_activity.last_charge_at을 만들 경우, “실제 결제 시각”이 아니라 “입금액이 갱신된(입력된) 시각”으로 정의하는 것이 현재 데이터로는 가장 정확하다.

권장 정의 예시
- external_ranking_data.deposit_amount가 증가(증분 > 0)한 upsert가 발생한 경우 last_charge_at = external_ranking_data.updated_at
- 입금액이 변하지 않았거나(증분 0) 사용자가 외부랭킹 row가 없다면 last_charge_at = NULL

주의: 향후 실제 결제 시각/거래 단위(입금 내역)를 정확히 추적하려면 deposit_transactions 같은 “입금 이벤트 로그 테이블”을 별도로 신설해야 한다.

user_segment
필드명	타입	설명
user_id	int PK, FK→user.id	사용자 ID
segment	varchar	세그먼트 이름 (e.g., NEW, DORMANT_SHORT, DORMANT_LONG, VIP 등)
updated_at	datetime	최근 분류 시각

세그멘테이션 엔진이 정기적으로 user_activity를 분석하여 갱신한다. 예) 마지막 충전 이후 7일–14일: DORMANT_SHORT, 14일 이상: DORMANT_LONG 등.

2.2 세그멘테이션 엔진 모듈

주기적 작업(Cron Job): 하루에 한 번 모든 user_activity 데이터를 읽어 user_segment 테이블을 업데이트한다. 예를 들어 last_charge_at과 total_play_duration 등을 기준으로 그룹을 분류한다.

모듈 구조(백엔드 기준):

- 예: scripts/segment_users.py (또는 app/jobs/segment_users.py)에서 SQLAlchemy로 user_activity를 읽고 user_segment를 갱신
- 실행은 Cron(서버) 또는 컨테이너 스케줄러에서 하루 1회 수행

분류 규칙은 DB 테이블(segment_rule)에 저장하여 운영자가 변경 가능하도록 구성할 수 있다.

현재 구현된 DB 규칙관리(세그멘테이션 룰)
- 테이블: segment_rule
	- name: 규칙 이름(UNIQUE)
	- segment: 결과 세그 코드(예: VIP, DORMANT_LONG)
	- priority: 작은 값이 우선(First-match-wins)
	- enabled: 사용 여부
	- condition_json: 규칙 조건(JSON)
- 어드민 API
	- 목록: GET /admin/api/segment-rules
	- 생성: POST /admin/api/segment-rules
	- 수정: PUT /admin/api/segment-rules/{rule_id}
	- 삭제: DELETE /admin/api/segment-rules/{rule_id}
- 어드민 UI
	- 화면: /admin/segment-rules
- 배치 연동
	- scripts/segment_users.py 실행 시 enabled 규칙을 priority 오름차순으로 평가하여, 첫 매칭 규칙의 segment를 적용한다.
	- 규칙이 0개이거나 매칭되는 규칙이 없으면 최소 하드코딩 규칙(NEW/DORMANT_SHORT/DORMANT_LONG/VIP)로 fallback 한다.

condition_json 포맷(현재 엔진 지원)
- 논리 조합
	- {"all": [cond, cond, ...]}
	- {"any": [cond, cond, ...]}
- 단일 조건
	- {"field": "deposit_amount", "op": ">=", "value": 1000000}
	- {"field": "days_since_last_active", "op": ">=", "value": 14}
	- {"field": "last_charge_at", "op": "is_null"}
- 지원 field
	- last_login_at, last_charge_at, last_active_at (datetime | null)
	- days_since_last_login, days_since_last_charge, days_since_last_active (int | null)
	- deposit_amount (int)
	- roulette_plays, dice_plays, lottery_plays, total_play_duration (int)
- 지원 op
	- ==, !=, >, >=, <, <=
	- is_null, not_null
- 제한(현재 구현)
	- datetime 필드끼리의 비교는 미지원(현재는 ValueError로 스킵됨). 날짜 비교가 필요하면 days_since_* 기반으로 조건을 구성한다.

3. (향후 설계 / 미구현) 캠페인·쿠폰·랜덤 리워드
3.1 캠페인 관리
데이터 구조

campaigns: id, name, segment(적용 세그먼트), start_at, end_at, reward_type, reward_value, message_template, status, created_at, updated_at.

campaign_logs: id, campaign_id, user_id, delivered_at, redeemed_at, status, meta_json.

API 및 백엔드 처리

향후 구현 시: 어드민 UI에서 /admin/api/campaigns (GET, POST, PUT, DELETE)으로 캠페인 CRUD를 수행한다. reward_type은 토큰, 포인트, 쿠폰 등이 될 수 있다.

발송 엔진: 백엔드에서 Cron job 또는 워커를 통해 실행 중인 캠페인을 찾아 각 세그먼트의 대상자에게 알림을 발송한다. 발송 후 campaign_logs에 기록한다.

퍼널/통계: 캠페인 별 전환율을 집계하기 위해 /admin/api/campaigns/:id/stats를 추가한다.

어드민 UI

어드민 대시보드에 “캠페인 관리” 메뉴를 추가한다. 테이블 형태로 캠페인 목록을 보여주고 생성/수정 폼을 제공한다.

react-hook-form과 react-query를 이용해 캠페인 폼 및 데이터 조회를 구현한다.

3.2 쿠폰 코드 & 페이백
데이터 구조

coupons: id, code, type(percentage/fixed/free_spin/bonus_token), value, expires_at, usage_limit, used_count, segment(옵션), created_at, updated_at.

coupon_redemptions: id, coupon_id, user_id, redeemed_at, amount.

기능

발급: 어드민 UI에서 쿠폰을 생성하고 사용 한도와 적용 세그먼트를 지정한다. /admin/api/coupons CRUD 제공.

향후 구현 시: 사용자 측에서 /api/coupons/redeem POST로 코드를 제출하면, 서버는 쿠폰을 검증하고 보상을 지급하며 coupon_redemptions에 기록한다.

페이백: 쿠폰 유형에 percentage를 사용하면 사용자 잔액의 일정 비율을 환급한다.

3.3 랜덤 리워드 풀
데이터 구조

reward_pools: id, name, segment(옵션), description.

reward_items: id, pool_id, reward_type(token/skin/coupon), reward_value, weight, quantity(수량 제한), meta_json.

향후 구현 시: 사용자가 일정 조건을 만족하면 /api/rewards/open/:pool_id를 호출하여 서버에서 가중치에 따라 아이템을 반환한다. 잔여 수량이 있으면 감소시키고, 결과를 play_logs/ledger에 기록한다.

어드민 UI

랜덤 리워드 관리 페이지에서 풀과 아이템을 등록·편집한다. /admin/api/reward-pools 엔드포인트로 CRUD 수행.

4. 후기 게시판 및 소셜 공유
4.1 후기 게시판 데이터 구조

posts: id, user_id, title, content, rating(별점), game(roulette/dice/lottery), created_at, updated_at.

post_votes: id, post_id, user_id, type(like/dislike), created_at.

후기를 홈/랭킹 페이지에 간단히 표시하고, 상세 페이지에서 댓글/좋아요 기능을 제공한다.

4.2 소셜 공유 기능

프론트엔드에 각 게임 결과 또는 레벨 레벨업 시 결과를 공유할 수 있는 버튼을 추가한다. 예) kakaoShare() 또는 navigator.share() API를 호출하여 결과 링크와 메시지를 공유한다. 어드민에서는 공유 메시지 템플릿을 설정할 수 있도록 /admin/api/social/share-template을 추가한다.

5. 어드민 UI 확장 및 기존 페이지 통합
5.1 신규 페이지 추가

세그먼트 관리: /admin/segments 경로를 추가하여 세그먼트 목록과 규칙 수정 폼을 제공한다.

캠페인 관리: /admin/campaigns에서 캠페인 목록, 생성/수정/삭제 UI를 제공한다.

쿠폰 관리: /admin/coupons에서 쿠폰 목록/생성/수정/삭제를 관리한다.

리워드 풀 관리: /admin/reward-pools에서 랜덤 리워드 풀과 아이템을 관리한다.

게시판 관리: /admin/posts에서 후기 게시글을 검열/삭제할 수 있는 기능을 제공한다.

각 페이지는 react-query를 통한 API 호출과 yup 기반의 입력 검증을 사용한다.

5.2 기존 컴포넌트 활용

Button, Table 등 공통 컴포넌트를 재사용하여 일관성 있는 UI/UX를 유지한다.

FeatureGate를 사용해 신기능을 단계적으로 배포한다.

6. (참고) API 변경 및 백엔드 작업 요약
작업	상세	영향
새로운 엔드포인트 구현(현재)	/api/activity/record	사용자 앱 activity 수집
어드민 API 확장(현재)	/admin/api/segments, /admin/api/segment-rules	세그/규칙 관리
향후 엔드포인트(미구현)	/api/coupons/redeem, /api/rewards/open/:pool_id, /admin/api/campaigns 등	캠페인/쿠폰/리워드
데이터베이스 마이그레이션	user_activity, user_segment, campaigns, campaign_logs, coupons, coupon_redemptions, reward_pools, reward_items, posts, post_votes 테이블 추가	백엔드 저장소 확장
Cron/워커 작업	세그멘테이션 엔진, 캠페인 발송, 랜덤 리워드 수량 감소 등	백엔드 작업자 필요
클라이언트 수정	새 페이지 라우팅, UI 컴포넌트, 훅 구현	프론트엔드 개발
7. 통합 및 배포 고려사항

스키마 버전 관리: 백엔드 코드와 DB 마이그레이션을 함께 버전 관리한다. 데이터 무결성을 위해 기존 테이블에 외래키 제약을 추가한다.

대량 데이터 처리: user_activity 업데이트 및 세그먼트 계산은 백엔드 워커(예: BullMQ)로 비동기 처리한다.

성능 최적화: user_activity와 play_logs 등에 인덱스를 추가해 조회 성능을 유지한다.

보안: 쿠폰 코드와 보너스 지급 시 재사용/중복 사용을 방지하도록 트랜잭션을 사용한다. 후기는 욕설 필터링·스팸 방지를 위해 검수 로직을 추가한다.

모바일 우선 UX: Tailwind의 모바일 퍼스트 설계 방법을 적용하여 모든 신규 페이지가 모바일 화면에서 잘 동작하도록 한다
tailwindcss.com
.